#!/usr/bin/python3

from advgame import stmsg as stmsg
from advgame.utils import roll_dice

from advgame.commands.be_atkd import be_attacked_by_command
from advgame.commands.constants import COMMANDS_SYNTAX, SPELL_DAMAGE, SPELL_MANA_COST


__all__ = ("cast_spell_command",)


def cast_spell_command(context, tokens):
    """
    Execute the CAST SPELL command. The return value is always in a tuple
    even when it's of length 1. Takes no arguments.

    * If any arguments are given, returns a .stmsg.command.BadSyntax object.

    * If the character is a Warrior or a Thief, returns a
    .stmsg.command.ClassRestricted object.

    * This command costs mana points. If the character doesn't have enough,
    returns a .stmsg.castspl.InsufficientMana object.

    * If the character is a Mage and there's no creature in the room,
    returns a .stmsg.castspl.NoCreatureToTarget object.

    * If they're a Mage and there is a creature present, a damaging spell
    is cast and the creature is wounded. If they don't die, returns a
    .stmsg.castspl.CastDamagingSpell object followed by the object(s)
    generated by the creature's followup attack.

    * If the creature is killed, returns a .stmsg.castspl.CastDamagingSpell
    object and a .stmsg.various.FoeDeath object.

    * If the character is a Priest, returns a
    .stmsg.castspl.CastHealingSpell object and a
    .stmsg.various.UnderwentHealingEffect object."""

    game_state = context["game_state"]

    # The first error check detects if the player has used this
    # command while playing a Warrior or Thief. Those classes can't
    # cast spells, so a command-class-restricted error is returned.
    if game_state.character_class not in ("Mage", "Priest"):
        return (stmsg.command.ClassRestricted("CAST SPELL", "mage", "priest"),)

    # This command takes no arguments, so if any were used a syntax
    # error is returned.
    elif len(tokens):
        return (stmsg.command.BadSyntax("CAST SPELL", COMMANDS_SYNTAX["CAST SPELL"]),)

    # If the player character's mana is less than SPELL_MANA_COST,
    # an insufficient-mana error is returned.
    elif game_state.character.mana_points < SPELL_MANA_COST:
        return (
            stmsg.castspl.InsufficientMana(
                game_state.character.mana_points,
                game_state.character.mana_point_total,
                SPELL_MANA_COST,
            ),
        )

    # The initial error handling is concluded, so now the execution
    # handles the Mage and Priest cases separately.
    elif game_state.character_class == "Mage":

        # If the current room has no creature in it, a
        # no-creature-to-target error is returned.
        if game_state.rooms_state.cursor.creature_here is None:
            return (stmsg.castspl.NoCreatureToTarget(),)
        else:
            # Otherwise, spell damage is rolled and inflicted on
            # creature_here. The spell always hits (it's styled
            # after _magic missile_, a classic D&D spell that always
            # hits its target.
            damage_dealt = roll_dice(SPELL_DAMAGE)
            creature = game_state.rooms_state.cursor.creature_here
            damage_dealt = creature.take_damage(damage_dealt)
            game_state.character.spend_mana(SPELL_MANA_COST)

            # If the creature died, a cast-damaging-spell value and
            # a foe-death value are returned.
            if creature.is_dead:
                corpse = creature.convert_to_corpse()
                game_state.rooms_state.cursor.container_here = corpse
                game_state.rooms_state.cursor.creature_here = None
                return (
                    stmsg.castspl.CastDamagingSpell(
                        creature.title, damage_dealt, creature_slain=True
                    ),
                    stmsg.various.FoeDeath(creature.title),
                )
            else:
                # Otherwise, like ATTACK, using this command and
                # not killing your foe means they counterattack.
                # cast-damaging-spell is conjoined with the outcome
                # of self._be_attacked_by_command() and the total
                # tuple is returned.
                be_attacked_by_result = be_attacked_by_command(context, creature)
                return (
                    stmsg.castspl.CastDamagingSpell(
                        creature.title, damage_dealt, creature_slain=False
                    ),
                ) + be_attacked_by_result
    else:
        # The Mage's spell is a damaging spell, but the Priest's
        # spell is a self-heal. The same SPELL_DAMAGE dice are used.
        # The healing is rolled and applied to the Character object.
        # A cast-healing-spell value and a underwent-healing-effect
        # value are returned.
        damage_rolled = roll_dice(SPELL_DAMAGE)
        healed_amt = game_state.character.heal_damage(damage_rolled)
        game_state.character.spend_mana(SPELL_MANA_COST)
        return (
            stmsg.castspl.CastHealingSpell(),
            stmsg.various.UnderwentHealingEffect(
                healed_amt,
                game_state.character.hit_points,
                game_state.character.hit_point_total,
            ),
        )
